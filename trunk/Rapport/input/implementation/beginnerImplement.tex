\chapter{Beginner's Algorithm}
\myTop{In this chapter the process of implementing the beginner's algorithm, which was described in the theory part, will be presented. This implementation will not be as effective as the beginner's algorithm is capable of being. The reason for this is that we only want our implementation to solve the \rubik{}, and the number of twists in this algorithm is of low priority.}
This chapter is divided into the different steps used in the beginner's algorithm.
Each step is using different algorithms which all are generally structured in the same way. 

For the sake of simplicity the first layer (down face) in our implementation will always be the same face. We have chosen that face to be the yellow face, the green is the front face, and the red is the right face. This will make the implementation process easier, but the solution will require more twists since it is unlikely that the yellow face is the optimal choice as the first layer face for every solve.

\section{Algorithms}
The implementation uses several algorithms which all are named algorithm X, where X is a natural number. There are 11 of these and they are all a set of twists that it performs. 

Most of them contains a switch/case statement which is dependent on some input specified for each algorithm. In all cases this is based on the point of view. Normally a human will simply rotate the whole \cube{} and perform the same algorithm, but we found it easier simply to define the algorithms from the different locations.

Here is an example of the source code of an algorithm used in the program.

\begin{lstlisting}[style=sourceCode, caption=\myCaption{This is algorithm 3, which will orientate the corners correctly. The for-loop is only for adding the moves to the console.}, label=src:beginners, float=htb]
private void algorithm3(CornerPos p){
	MoveButtons[] moves;
	switch(p){
	case P1S0T0:
		moves = new MoveButtons[]{ LP, UP, L, U, LP, UP, L};
		break;
	case P1S0T1:
		moves = new MoveButtons[]{ R, UP, RP, U, R, UP, RP};
		break;
	case P1S1T0:
		moves = new MoveButtons[]{ L, UP, LP, U, L, UP, LP};
		break;
	default:
		moves = new MoveButtons[]{ RP, UP, R, U, RP, UP, R};
		break;
	}
	Cube.permute(cube, moves);
	for(int i = 0; i < moves.length; i++){
		this.moves.add(moves[i]);
	}
}
\end{lstlisting}

This algorithm is used in the second step of the beginner's algorithm. It rotates a corner \cpiece{} which is in its correct orientation. Which corner that is rotated is based on which is input. 

\input{input/implementation/beginnersAlg/step1}
\input{input/implementation/beginnersAlg/step2}
\input{input/implementation/beginnersAlg/step3}
\input{input/implementation/beginnersAlg/step4}
\input{input/implementation/beginnersAlg/step5}
\input{input/implementation/beginnersAlg/step6}
\input{input/implementation/beginnersAlg/step7}

\section{Twist shortening}
As mentioned before our implementation of the beginner's algorithm is not as efficient as it can be. We can however take some steps towards improving its efficiency. One of these steps is removing unnecessary moves and replacing a move sequence with a shorter move sequence, which give the same result.

An unnecessary move sequence can be performing a twist and just after that twist perform its inverse move. e.g. performing \m{U U'} or \m{U' U}.
According to the theory of groups \ref{sec: groupDefinition}.

It was necessary to be able to shorten the twists generally, so any move sequence can not be replaced with a shorter one in our program.
An example of replacing a move sequence with a shorter one generally is replacing three of the same type of move with a single inverse move of that type. e.g. \m{U U U} also noted as \m{U2 U} or \m{U U2} can be replaced with a single inverse move \m{U'}. This is also described in the group theory chapter \ref{sec: groupDefinition}.

\input{input/implementation/beginnersAlg/effeciency}