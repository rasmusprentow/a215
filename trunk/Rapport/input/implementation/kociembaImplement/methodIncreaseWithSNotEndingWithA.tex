\section{The Move Incrementing Methods}
\label{sec:increaseWithSNotEndingWithA}
The method named \vr{increaseWithSNotEndingWithA} (see code snippet \ref{src:kociemba2}) increments a move sequence.
When the method is called it takes two parameters, a move sequence of the type MoveButtons and an integer.
As the method initializes it creates two variables of the type integer, \vr{length} and \vr{i}.
The variable \vr{length} is set equal to the length of the move sequence, so every time the length of the move sequence is needed the variable \vr{length} will be used.
The variable \vr{i} is used to keep track of where in the move sequence a move is changed and it is set equal to the input integer parameter. 

\begin{lstlisting}[style=sourceCode, caption=\myCaption{Key point in the incrementing method of kociemba's optimal solver}, label=src:kociemba2]
if (i == length - 1) {
	try {
		do {
			moveSequence[i] = (MoveButtons)S.toArray()[moveSequence[i].ordinal() + 1];
		} while(A.contains(moveSequence[i]));
		try {
			if(isSameFace(moveSequence[i], moveSequence[i-1])) {
				increaseWithSNotEndingWithA(moveSequence, i);
			} else {
				Cube.permute(cube, moveSequence[i]);
			}
		} catch (ArrayIndexOutOfBoundsException e2) {
			Cube.permute(cube, moveSequence[i]);
		}
		return;
	} catch (ArrayIndexOutOfBoundsException e) {
		moveSequence[i] = F;
		i--;
		try {
			Cube.permute(cube, moveSequence[i].invert());
			moveSequence[i].invert();
		} catch (ArrayIndexOutOfBoundsException e4) {
			throw new UnableToIncreaseMoveSequenceException();
		}
			increaseWithSNotEndingWithA(moveSequence, i);
		return;
	}
}
\end{lstlisting}

The last move performed on the cube can never be an \m{A} move since \m{A} is a closed group, see section \ref{sec:subgroup}.
At first the method tests if it is working with the last move, if this is the case then a \textbf{do-while} loop will be executed.
Inside this loop the parameter \vr{moveSequence} will be updated with a move from \m{S}, but the condition in the loop is that it must run while the enumset \m{A} contains the new updated move.
When a move not in \m{A} is found, then the loop is ended.

After the loop is over a new method is called, \vr{isSameFace} this method tests if the new move is the same as the move before this.
If they are the same (see section \ref{sec:groupDefinition}), then the method will call itself with the last move as a parameter else it will permute the cube with the current move sequence.
When the \rubik{} has been permuted it will \vr{return} and the method will end.

The method increments the move, and at some point it will reach the end of the enumset.
When this occurs an \vr{ArrayIndexOutOfBoundsException} will be thrown, this exception is caught in a \textbf{try-catch}.
If the exception is caught then the last place in the move sequence array will be set equal to the move \m{F}.
After this the counter variable \vr{i} will be decremented.
Then the method will call itself, and after it has increased the second last move it will \textit{return} and end the method.

\begin{lstlisting}[style=sourceCode, caption=\myCaption{The definition of the enumsets S, A, and notA.}, label=src:enumset]
private EnumSet<MoveButtons> S = EnumSet.of(U, UP ,U2, D, DP, D2, F, FP, F2, B, BP, B2, L, LP, L2, R, RP, R2);
private EnumSet<MoveButtons> A = EnumSet.of(U, UP ,U2, D, DP, D2, F2, B2, L2, R2);
private EnumSet<MoveButtons> notA = EnumSet.of(F, FP, B, BP, L, LP, R, RP);
\end{lstlisting}

All this code are executed if and only if the first condition is true.
If it is false, then the method will start increasing the current move with a textit{S} move.
This is done the same way as above, except there is no do-while loop around it since we are interested in all the moves in textit{S}.

When the method tests if two moves are the same, just as it did before if the first condition was true.
It will now test if all the moves from the current position \textit{i} to the \textit{length}.
This is done with a for-loop that count every step, and the same code snippet that tested if they were on the same face.

Again we have been able to reuse the same code snippet.
When the method gets to the end of the enumset S, it will set the move to the first move in S.
This is done with the same code as before, except this time it sets the move to \textit{U}.