\chapter{Conclusion}
\emptyTop{}
Before we started the writing process we gathered information about what we found to be interesting aspects of the \rubik{}. 
These aspects included the different solving algorithms and some general mathematical theories that could be applied to the \rubik{}.
After gathering sufficient information we formulated a problem statement. Our problem statement is as follows:

\input{input/introduction/problemStatement2}
\ \\ \linebreak 
The upper bound has been lowered several times, since Thistlewaite set the upper bound to 52 in 1981, while the lower bound has only been altered once since then (see chapter \ref{chap:bounds}).

The upper bound of 22 has been found by dividing the positions of the \rubik{} into cosets.  Rokicki's set solver (see chapter \ref{sec:setSolver}) was able to test if an entire set of positions needs 22 twists or less to solve the \rubik{}. The result showed that no \rubik{} position needs more than 22 twists to solve.

The lower bound was proven by testing all sequences of twists on the superflip position with a length shorter than 20, and finding that none of these solved this position. Thereby the lower bound was proven to be 20. 


In order to compare the two implementations several tests must be run in a controlled environment with as little human interference as possible. 

From our tests we can conclude that our implementation of beginner's algorithm is a time-wise more efficient algorithm than our implementation of Kociemba's optimal solver. 
Our implementation of beginner's algorithm is $1.2\cdot10^{18}$ times faster than our implementation of Kociemba's optimal solver on average. 

In average our implementation of beginner's algorithm uses 151 twist to solve a \cube{} while our implementation of Kociamba's optimal solver always solves a \cube{} with an optimal solution which is known to be no more than 22. 
By this we conclude that our implementation of Kociemba's optimal solver is twist-wise more efficient than our implementation of beginner's algorithm. 




\begin{comment}
That is why an application, where a user can scramble but only the application performs the solving algorithms, is a good choice when running a test.
After we implemented the algorithms, we tested their efficiencies separately.
Our implementation of the beginner's algorithm was run 100,000 times, and the average length of the twist sequence that solved the \rubik{} was found to be 151 as well as the time spent on solving them which were XXXXXX. See section \ref{sec:beginnersStat}. 
Our implementation of Kociemba's optimal solver was run over a period of 48 hours. By this we estimated the time it would take to find an optimal solution of a \rubik{}, which were XXXX years. See section \ref{app:kociembaTime}.
\end{comment}



\begin{comment}
There are many algorithms, which can solve the \rubik{}. 
There are generally two types of algorithms; algorithms for human solving and algorithms for computer solving. 
A requirement for the human algorithms is that one should be able to remember it, which limits the effectiveness. 
The computer algorithms are generally based upon systematic trial and error, which is why they are not effective to use as a human solver.
The human algorithms are time-wise efficient both for a human and a computer solver, but are not twist-wise efficient.
The computer algorithms require a lot of time, but give a twist-wise efficient result.
\end{comment}