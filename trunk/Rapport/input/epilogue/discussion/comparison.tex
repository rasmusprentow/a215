\section{Comparing the Implemented Algorithms}
The two algorithms implemented in our application differs a lot from each other when looking at efficiency. 
%Our implementation of Kociemba's optimal solver is twist-wise efficient but time-wise inefficient while the opposite applies to our implementation of beginner's algorithm. 
Our implementation of Kociemba's optimal solver is a twist-wise optimal solver, i.e. it uses the least amount of \twist{}s needed to solve any position (see section \ref{sec:kociemba}).
The time-wise efficiency for Kociemba's optimal solver is not impressive.
On a 2,5 GHz Quad Core, it would use approximately 18 million years to solve a \cube{} 18 \twist{}s\footnote{Most positions can be solved in 18 \twist{}s \cite{kociemba09}} away from the solved state (see section \ref{app:kociembaTime} for detailed calculations).   
On a test the \rubik{} will almost certainly have an optimal solution which goes into \m{H} and then starts to use \m{A} \twist{}s and thus lowering the search time substantially.
Depth 18 in \m{H} is finished in approximately 256 years compared to the 18 million years it would take to solve the \cube{} outside \m{H}, which is why the search time is lowered substantially.



Our implementation of beginner's algorithm is not designed for twist-wise or time-wise efficiency. However it uses less than a second to solve 1000 \cube{}s (see section \ref{sec:beginnersStat}). 
Twist-wise it is way less efficient since it uses an average of 151 moves to solve a scrambled \cube{} (see section \ref{sec:beginnersStat}).
%; where a human speed cuber uses around 60 \twist{}s in average \cite{larsPetrus97} \cite{cubeFreak}.

Time-wise beginner's algorithm is more efficient than Kociemba's optimal solver.
Specifically it is 
\begin{equation*}
\frac{5.5383 \cdot 10^{17} \text{ ms}}{0.478923077 \text{ ms}} \approx 1.2 \cdot 10^{18}
\end{equation*}
times faster on average.
However this is based on that the shortest solution found by Kociemba's optimal solver is by not going into \m{H} and using \m{A} \twist{}s.

With respect to the number of \twist{}s Kociemba's optimal solver always gives the shortest \twist{} sequence.
Since it will simply brute force its way to a solution with a breadth first search.
In our test of our implementation of beginner's algorithm we never got an optimal solution, which illustrates that beginner's algorithm will never be as twist-wise efficient as Kociemba's optimal solver.

From this discussion we can conclude that beginner's algorithm is a time-wise more efficient algorithm than Kociemba's optimal solver.
This was expected since beginner's algorithm will use a ``recipe'' to solve the \rubik{} where Kociemba's optimal solver tests every possible \twist{} sequence until it gets into \m{H}. This will in most cases require a lot of \twist{}s compared to the maximum of 241, which beginner's algorithm uses to solve a \rubik{}, which is scrambled with 50 twists.
Furthermore we can conclude that beginner's algorithm is unable to solve a \rubik{} with an optimal solution.
This is quite obvious since beginner's algorithm is divided into steps and it is very unlikely that these steps will go directly towards the solved state.