\section{Proof of the Upper Bound}
The upper bound of the \rubik{} is the lowest number of twists needed to solve the \rubik in the worst case. The upper bound has been proven to be equal to or less than a certain number of twists. Such proofs have been published several times, and the upper bound has been lowered each time. A major breakthrough was when Thistlewaite's algorithm was proven to be able to solve an arbitrary cube in 52 twists or under. Since then... BLA BLA BLA
%INTRODUCTION
%BLEVET BRUGT TIL AT BEVISE MED STØRRE ANTAL TRÆK

\subsection{Set Solver}
The algorithm used to prove the current lowest upper bound is known as a set solver and uses Kociemba's algorithm. The set solver is a viable method for proving the upper bound because it does not solve every single cube but a whole set of cubes at the time as the name suggests. This means that it solves approximately 19.5 billion cubes at a time.
The set solver does this by finding all the move sequences of a relabeled cube of the distance $d$ that transforms the cube into $H$. %All the move sequences to transform the unlabeled cube to $e$ is in a database so it is fast to find the shortest move sequence, once the move sequence to $H$ has been found.

\begin{algorithm}[!h]                     
\caption{Set Solver \cite{rokicki09}}          
\label{alg:setSolver}        
\begin{algorithmic}[1]
\STATE {$f=null$}
\STATE {$d=0$}
\WHILE {true} 
		\IF {$d \leq m$}
			\FOR {$b \in S^d$}
				\IF {$r(ab) = r(e)$}
					\STATE {$f = f \cup ab$}
				\ENDIF
			\ENDFOR
		\ENDIF
		\IF {$f = H$}
			\STATE {return $d$}
		\ENDIF
	\STATE {$d = d + 1$}
	\STATE {$f = f \cup fA$}
	\IF {$f = H$}
		\STATE {return $d$}
	\ENDIF
\ENDWHILE
\end{algorithmic}
\end{algorithm}

First in the set sovler two variables are initialized. The first one $f$ is a set that can hold all the positions of $H$ is set to $null$. The second variable is the distance $d$, which is the distance from a scrambled position $a$ to a position in $H$. This distance $d$ is set to $0$.

Next the while loop is run. It will run until $d$ is returned, which is when all positions in $H$ has been found or $d$ has reached it's maximum limit, $m$.

If $d$ is lower than or equal to $m$ a for loop will be run. This loop performs all possible move sequences of the the length $d$, and adds the position $ab$ to $f$ if it is a position in $H$. 
For efficiency's sake move sequences that give the exact same position more than once are not used. If a move sequence contained F F', that part would be unnecessary. 

if $f$ is equal to $H$ all positions in $H$ have been found, $d$ is returned and the algorithm has finished. 
If not $d$ is incremented by one. 
The different $A$ moves are performed on all the current $H$ positions in $f$ and the new $H$ positions are saved in $f$.
If $f$ contains all positions in $H$, $d$ is returned -- if not the while loop continues.

%Nyt afsnit nu?

When the algorithm has finished all the different possible $H$ positions should be saved, if the maximum distance $m$ is set sufficiently high. The theoretically highest number of twists needed to transform any scrambled cube to $H$ is 12, but more positions are found if it is set higher. This is because the set solver both performs $A$ moves on a cube in $H$, which gives more $H$ positions. The set solver also performs moves that transforms a cube in $H$ to a cube not in $H$ and then back again by using $S$ moves.

%As $m$ gets higher the CPU time needed to finish the algorithm grows exponentially. 


%RESULTATER