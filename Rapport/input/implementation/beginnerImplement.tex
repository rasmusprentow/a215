\chapter{Beginner's Algorithm}
\myTop{In this chapter the process of implementing the beginner's algorithm, which was described in the theory part. This implementation will not be as effective as the beginner's algorithm is capable of being. The reason for this is that we only want our implementation to solve the \cube{}, and the number of twists in this algorithm is of low priority.}

This chapter is divided into the different steps used in the beginner's algorithm.
Each step is using different algorithms which all are structured the same way. The algorithms are all using a switch/case statement, which does something different depending on the \cpiece{} to be moved. The algorithm performed is actually the same if the cube were rotated, but this is not implemented so the switch case solution will be used.

For the sake of simplicity the first layer(down face) in our implementation will always be the same face. We have chosen that face to be the yellow face, the green is the front face, and the red is the right face. This will make the implementation process easier, but the solution will require more twists since it is unlikely that the yellow face is the optimal choice as the first layer face for every solve.

\subsubsection{Algorithms}
The implementation uses several algorithms which all have in common that they are named algorithm X, where X is a natural number. There are 11 of these and they are all a set of twists that should be performed. 

Most of them contains a switch/case statement which is dependent on some input specified for each algorithm. In all cases this is based on the angle of view. Normally a human will simply rotate the whole \cube{} and perform the same algorithm, but we found it easier simply to define the algorithms from the different view perspectives. 
\begin{verbatim}
private void algorithm3(CornerPos p){
		MoveButtons[] moves;
		switch(p){
		case P1S0T0:
			moves = new MoveButtons[]{ LP, UP, L, U, LP, UP, L};
			break;
		case P1S0T1:
			moves = new MoveButtons[]{ R, UP, RP, U, R, UP, RP};
			break;
		case P1S1T0:
			moves = new MoveButtons[]{ L, UP, LP, U, L, UP, LP};
			break;
		default:
			moves = new MoveButtons[]{ RP, UP, R, U, RP, UP, R};
			break;
		}
		Cube.permute(cube, moves);
	}
\end{verbatim}
This algorithm takes a corner position and based on that it knows which type of moves that needs to be applied. The Cube object has a property permute which allows for several moves to be applied at the same time. The \textit{MoveButtons} type is a Enumeration which contains the buttons used in the GUI. The same enumeration is used to determine moves. Even though this seems confusing it proved quite worthwhile, since it allows for some smart maneuvers. 

\input{input/implementation/beginnersAlg/step1}
\input{input/implementation/beginnersAlg/step2}
\input{input/implementation/beginnersAlg/step3}
\input{input/implementation/beginnersAlg/step4}
\input{input/implementation/beginnersAlg/step5}
\input{input/implementation/beginnersAlg/step6}
\input{input/implementation/beginnersAlg/step7}

\section{Twist shortening}
The implementation of the beginners algorithm is not the most efficient twist wise, so in order to reduce the amount of twist used can easily be reduced. Based on the group theory (ref) it is known that some moves can be reduced. This is inverse moves and  three or two equal moves  in a row. e.g.  the twists U U U is equivalent to U'. Also U' and U are each others inverses and are equivalent to doing nothing. 