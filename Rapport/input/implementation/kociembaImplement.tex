\chapter{Kociemba's Optimal Solver}
\label{chap:kociembaImplement}
\myTop{The actual implementation of Kociemba's optimal solver will be covered in this chapter. The reader will be presented with general description of how we have chosen to implement Kociemba's optimal solver along with a detailed explanation of key points of the source code.}
The basics of Kociemba's optimal solver have been covered in section \ref{sec:kociemba}. The algorithm which we are implementing differs from the original at one point:
We are interested in the shortest move sequence to solve a scrambled cube, where as the original Kociemba optimal solver only finds the shortest length, not the actual sequence of moves \cite{rokicki09}.

Because of this we have chosen not to have a lookup table since it would have to contain 20 billion move sequences, which is impossible on today's computers. Considering that the lookup table only contains the length, it would have a size of 4 GB \cite{cubeExplorer}. A table containing the move sequences would have to be much larger.

An $A$ move can be defined using 4 bits.
The 4 bits gives $2^4=16$ different spaces and there are 10 $A$ moves, which mean they will fit.
To calculate the size of a lookup table containing the move sequence is just a matter of multiplying the size of one move with the number of moves in a sequence, e.g. a move sequence of the length 14 would have the size: $4 \cdot 14 = 56$ bits.
This size is again multiplied with the number of positions which needs this length for solving.
The size of a lookup table containing every move sequences to solve the \rubik{} inside \m{H} would be: $987$ GB (see appendix \ref{chap:sizeOfLookup}), which exceeds the average memory on today's computer \cite{averageRAM} \cite{maxRAM2}.
Instead of the lookup table our solver will have to try every move sequence inside \m{H} in order to find the shortest one, which solves the \rubik{}.

A flowchart of our implementation is shown in figure \ref{fig:kociembaFlow}.
The method starts with the \rubik{} in the position it has to be solved from.
It starts by testing if the \rubik{} is solved, if this is the case it will return.
If the \rubik{} is not solved the method will test if the \rubik{} is inside \m{H}, if this is the case it will call the method solveFromH.
The method solveFromH is build up using the same flow chart except the three boxes with a marked edge.
The differenceses is described short here.

\begin{enumerate}
	\item It creates a move sequence consisting of \vr{A} moves instead of \vr{S} moves.
	\item It test if the cube is solved instead of testing if it is in \m{H}.
	\item It increments the move sequence with an \m{A} move.
\end{enumerate} 

If the \rubik{} is not in \m{H}, then a move sequence will be initialized with a predefined length.
The move sequence will be made so two moves after each other are not on the same face (see section \ref{sec:groupDefinition}) and not ending with an \m{A} move.
For instance an initialized move sequence of the length 5 would consist of the following moves: \m{U D U D F}.
Now the \rubik{} is permuted with the initialized move sequence and 


\begin{comment}
As in the flowchart $b$ is a move sequence variable, which takes the scrambled cube into \m{H}. $d$ is the depth, i.e. the number of moves in $b$, $c$ is the move sequence which solves the cube when it gets inside \m{H}, and $e$ is the depth which the \m{H} solver is searching. $result$ is the shortest move sequence found to solve the cube, this is updated every time a shorter move sequence is found.
\end{comment}

\begin{figure}[htbp]
	\centering
			\includegraphics[width = \textwidth, trim = 0mm 110mm 50mm 0mm, clip]{input/pics/kociambav2.pdf}
	\caption{\myCaption{A flow chart of our implementation of Kociemba's optimal solver.}}
	\label{fig:kociembaFlow}
\end{figure}


	\input{input/implementation/kociembaImplement/incMoveSequence}
	\input{input/implementation/kociembaImplement/methodSolve}
	\input{input/implementation/kociembaImplement/methodIncreaseWithSNotEndingWithA}

\myTail{This chapter has shown how we have implemented Kociemba's optimal solver, with descriptions of key points of the source code.}