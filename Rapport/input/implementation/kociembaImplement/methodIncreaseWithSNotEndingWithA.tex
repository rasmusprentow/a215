\section{Method Increase With S Not Ending With A}

The method increaseWithSNotEndingWithA increments a move sequence.
When the method is called it takes two parameters, a move sequence of the type MoveButtons and an integer.
As the method initializes it creates two variables of the type integer, \textit{length} and \textit{i}.
The variable \textit{length} is set equal to the length of the move sequence, so every time the length of the move sequence is needed the variable \textit{length} will be used.
The variable \textit{i} is used to keep track of where in the move sequence a move is changed and it is set equal to the integer parameter. 

The last move performed on the cube can never be a move from the group A (maaske referance til der hvor det staar).
At first the method test if it is working with the last move, if this is the case then a do-while loop will be executed.
Inside this loop the parameter move sequence will be updated with a move from S, but the condition in the loop is that it shall run while the enumset A contains the new updated move.
When a move not in A is found, then the loop is ended.
A code snippet is shown here:

\begin{verbatim}
if (i == length - 1) {
	do {
		moveSequence[i] = (MoveButtons)S.toArray()[moveSequence[i].ordinal() + 1];
	} while(A.contains(moveSequence[i]));
\end{verbatim}

When the loop is over a new method is called, \textit{isSameFace} this method tests if the new move is the same as the move before this.
If they are the same, then the method will call itself else it will permute the cube with the current move sequence.
When the \rubik{} has been permuted it will \textit{return} and method will end.
A code snippet is shown here:

\begin{verbatim}
if(isSameFace(moveSequence[i], moveSequence[i-1])) {
	increaseWithSNotEndingWithA(moveSequence, i);
} else {
	Cube.permute(cube, moveSequence[i]);
}
return;
\end{verbatim}

When the method tries to increase the move, it will at some point reach the end of the enumset with moves.
When this occurs an \textit{ArrayIndexOutOfBoundsException} will be thrown, this exception is caught in a try-catch.
If the exception is caught then the last place in the move sequence array will be set equal to the move F.
After this the counter variable \textit{i} will be decremented.
Then the method will call itself, and after it has increased the second last

\begin{verbatim}
moveSequence[i] = F;
i--;
increaseWithSNotEndingWithA(moveSequence, i);
return;
\end{verbatim}




\begin{verbatim}

		
			} catch (ArrayIndexOutOfBoundsException e) {
				moveSequence[i] = F;
				i--;
				try {
					Cube.permute(cube, moveSequence[i].invert());
					moveSequence[i].invert();
				} catch (ArrayIndexOutOfBoundsException e4) {
					throw new UnableToIncreaseMoveSequenceException();
				}

				increaseWithSNotEndingWithA(moveSequence, i);
				return;
			}
		} else {
			try {
				moveSequence[i] = (MoveButtons)S.toArray()[moveSequence[i].ordinal() + 1];
				for (int j = i ; j < length; j++) {
					try {
						if(isSameFace(moveSequence[j], moveSequence[j-1])) {
							increaseWithSNotEndingWithA(moveSequence, j);
							return;
						} else {
							Cube.permute(cube, moveSequence[j]);
							//System.out.println(moveSequence[j]);
						}
					} catch (ArrayIndexOutOfBoundsException e2) {
						Cube.permute(cube, moveSequence[j]);
						//System.out.println(moveSequence[j]);
					}
				}
				return; 
			} catch (ArrayIndexOutOfBoundsException e) {
				moveSequence[i] = U;
				i--;
				try {
					Cube.permute(cube, moveSequence[i].invert());
					//System.out.println(moveSequence[i]);
					moveSequence[i].invert();
				} catch (ArrayIndexOutOfBoundsException e4) {
					throw new UnableToIncreaseMoveSequenceException();
				}
				increaseWithSNotEndingWithA(moveSequence, i);
				return;
			}
		}
	}
	
\end{verbatim}