\section{The Solving Method}
\label{sec:kSolve}
The method named \vr{solve} connects all the submethods into one big method that apply Kociemba's algorithm onto the \rubik{}. 
It start with initializing five variables; 
an array \vr{result} which will contain the final move sequence, an integer \vr{d} which will determine the search depth, 
an integer \vr{l} which also is used to determine the search depth, 
an array \vr{b} which will contain the move sequence until the \rubik{} enters \m{H} 
and an array \vr{c} which will be the move sequence after the \rubik{} has entered \m{H}.
%evt s√¶tte de 5 variabler i punktform??

\begin{lstlisting}[style=sourceCode, caption=\myCaption{Key point in the solve method of kociemba's optimal solver}, label=src:kociemba]
try {
	c = solveFromH(l - d);
	if (d + c.length < l) {
		curTime = System.currentTimeMillis();
		l = d + c.length;
		result = new MoveButtons[l];
		output.addTextln("The solutions of the length " + l + ". The solution is:");
		int j = 0;
		for ( ; j < d; j++) {
			result[j] = b[j];
			output.addText(b[j] + " ");
		}
		for (int k = 0 ; k < c.length; k++,j++) {
			result[j] = c[k];
			output.addText(c[k] + " ");
		}
		output.addTextln("");
		output.addTextln("Time spend: " + ((curTime - startTime)/1000) + " seconds");
	}
} catch (InvalidCube e) {}
\end{lstlisting}

The program start with the \vr{solveFromH} method to test if the cube is in \m{H}. The method \vr{solveFromH} is called with a parameter, which determines how deep it will search. If the \rubik{} is in \m{H} then the method will start solving it with \m{A} moves.

Thereafter it tests if \vr{d + c.length} is lower than \vr{l}. 
If that is true, \vr{l} will be set equal to the sum of \vr{d + c.length} and the \vr{result} array will be initialized with the size \vr{l}. 
In the \vr{result} array the move sequence \vr{b} and the movesequence \vr{c} is added and the console will print the current \vr{result} and the time it took in seconds.

After the method has tested if \vr{d + c.length < l} the method will permute the \rubik{} back with the inverse of the last move. When it has been permuted the method \vr{increaseWithSNotEndingWithA} will be called. See section \ref{sec:increaseWithSNotEndingWithA}.

When the method \vr{increaseWithSNotEndingWithA} throws an exception of the type \vr{UnableToIncreaseMoveSequenceException} the method increments \vr{d}. 
When \vr{d} is incremented to \vr{l} the method will return the \vr{result} array.